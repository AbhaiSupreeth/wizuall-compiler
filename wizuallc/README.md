# WIZUALL Compiler (wizuallc)

This compiler translates WIZUALL source code into C code, which can then be compiled and run. Includes a simple scatter plot visualization primitive.

## Prerequisites

*   A C compiler (like `gcc` or `mingw-w64`)
*   `make` (like `mingw32-make` on Windows/MinGW)
*   `flex`
*   `bison`
*   `gnuplot` (must be in the system PATH for visualization)

## Building the Compiler

To build the WIZUALL compiler itself (`wizuallc`), run:

```bash
make
# or: mingw32-make 
```

This will compile `main.c`, `ast.c`, `symtab.c`, `codegen.c`, and the Flex/Bison generated files into the `wizuallc` executable.

## Generating C Code

To translate a WIZUALL source file (e.g., `examples/test1.wz`) into C code:

```bash
./wizuallc examples/test1.wz
# or: .\wizuallc examples/test1.wz
```

This will parse the file, print the AST (for debugging), and generate a C source file named `output.c` in the current directory.

## Compiling the Generated Code

After generating `output.c`, you can compile it, linking it with the WIZUALL runtime code (needed for functions like `scatter_plot`), using `make`:

```bash
make output_executable
# or: mingw32-make output_executable
```

This uses the rule defined in the `Makefile` to compile `output.c` (linking with the math library `-lm`) and creates an executable named `output_executable` (or `output_executable.exe` on Windows).

## Running the Executable

Finally, run the executable generated from the C code:

```bash
./output_executable
# or: .\output_executable.exe 
```

This will run the C code that corresponds to your original WIZUALL program.

## Cleaning

To remove the compiler executable (`wizuallc`), the generated C file (`output.c`), the final executable (`output_executable`), plot files (`plot_data.txt`, `plot_output.png`), and the build directory:

```bash
make clean
# or: mingw32-make clean
```

## Directories

- `src/` — Compiler source files (.c, .l, .y) including `runtime_viz.c`
- `include/` — Compiler header files (.h) including `runtime_viz.h`
- `build/` — Intermediate build output (object files, generated parser/lexer C files)
- `examples/` — Example WIZUALL code (.wz)
- `output.c` — Generated C code (created in root directory)
- `output_executable` — Final executable compiled from output.c (created in root directory)
- `plot.gp` — Gnuplot script for scatter plot
- `plot_data.txt` — Data file generated by scatter_plot 

# Design Report

## 1. Expected Input-Output Relationship and Pipeline

The WIZUALL compiler (`wizuallc`) processes a WIZUALL source file (`.wz`) and translates it into a C source file (`output.c`). This generated C code can then be compiled using a standard C compiler (like GCC) into a native executable (`output_executable`).

The compilation pipeline is as follows:

1.  **(Optional Preprocessing):** A user might use a script like `preprocess.py` to extract numeric data from a mixed text file, producing output suitable for piping into the executable.
    ```bash
    python preprocess.py data_input.txt > numeric_data.txt 
    ```
2.  **WIZUALL Compilation:** The `wizuallc` compiler reads a `.wz` file.
    ```bash
    ./wizuallc your_program.wz 
    ```
    This performs:
    *   **Lexical Analysis:** Breaks the input into tokens (numbers, identifiers, operators, keywords).
    *   **Syntax Analysis:** Parses the token stream according to the WIZUALL grammar, building an Abstract Syntax Tree (AST).
    *   **Symbol Table Management:** Creates and populates a symbol table for identifiers encountered.
    *   **Semantic Analysis (Basic):** Performs type checks during code generation (e.g., for assignments, operations, function arguments). Reports errors to `stderr`.
    *   **Code Generation:** Traverses the AST and generates equivalent C code, writing it to `output.c`. This includes C implementations of runtime helper functions (vector operations, `read_vector`, `scatter_plot`).
3.  **C Compilation:** The generated `output.c` is compiled using a C compiler, linking necessary libraries (like the math library `-lm`) and the compiled WIZUALL runtime code (`runtime_viz.o`). The `Makefile` provides a target for this step.
    ```bash
    make output_executable 
    ```
4.  **Execution:** The final native executable is run.
    ```bash
    ./output_executable
    # Or, piping preprocessed data:
    # python preprocess.py data_input.txt | ./output_executable 
    ```
    During execution, the C code performs the calculations. If `read_vector()` is called, it prompts for and reads data from `stdin`. If `scatter_plot()` is called, it writes data to `plot_data.txt` and attempts to invoke `gnuplot` using the `plot.gp` script. Runtime errors (e.g., vector size mismatch) are reported to `stderr`.

## 2. Program Structure

A WIZUALL program consists of a sequence of statements.

*   **Statements:** End with a semicolon (`;`). Supported statements include assignments, expressions (whose value is discarded), `if`/`else` conditional statements, `while` loops, and function calls.
*   **Blocks:** Sequences of statements can be grouped into blocks using curly braces `{ ... }`. Blocks are typically used as the body for `if`, `else`, and `while`.
*   **Comments:** Single-line comments start with `#` and extend to the end of the line. They are ignored by the lexer.
*   **Delimiters:** Parentheses `()` group expressions and enclose conditions/arguments. Square brackets `[]` define vector literals. Commas `,` separate elements in vector literals and arguments in function calls.

## 3. The Syntax (Bison Grammar)

The following grammar rules define the syntax accepted by the parser (`src/parser.y`):

```bison
/* Grammar Rules */

program: statement_list
    { ast_root = $1; /* Assign the final list to the global root */ }
    ;

statement_list: /* empty */
    { $$ = ast_new_statement_list(); }
    | statement_list statement
    { if ($2) ast_add_statement($1, $2); $$ = $1; /* Add non-null statement */ }
    ;

statement: assignment ';'
    { $$ = $1; }
    | expression ';'
    { $$ = $1; }
    | vector ';' /* Allow vector literals as statements? Usually part of expression. */
    { $$ = $1; } /* Might want to remove this standalone vector statement later */
    | block
    { $$ = $1; /* Block itself is a statement list node */ }
    | IF '(' expression ')' statement %prec IFX /* Dangling else resolution */
    { $$ = ast_new_if($3, $5, NULL); }
    | IF '(' expression ')' statement ELSE statement
    { $$ = ast_new_if($3, $5, $7); }
    | WHILE '(' expression ')' statement
    { $$ = ast_new_while($3, $5); }
    | ';' /* Empty statement */
    { $$ = NULL; }
    ;

block: '{' statement_list '}'
    { $$ = $2; /* Return the statement list node */ }
    ;

assignment: ID '=' expression
    { $$ = ast_new_assignment($1, $3); /* $1 is Symbol* from lexer */ }
    ;

expression: NUMBER
    { $$ = ast_new_number($1); /* $1 is double from lexer */ }
    | ID
    { $$ = ast_new_identifier($1); /* $1 is Symbol* from lexer */ }
    | vector
    { $$ = $1; }
    | func_call
    { $$ = $1; } // Function call is an expression
    | expression '+' expression { $$ = ast_new_binary_op('+', $1, $3); }
    | expression '-' expression { $$ = ast_new_binary_op('-', $1, $3); }
    | expression '*' expression { $$ = ast_new_binary_op('*', $1, $3); }
    | expression '/' expression { $$ = ast_new_binary_op('/', $1, $3); }
    | '-' expression %prec UMINUS /* Unary minus */
    { $$ = ast_new_unary_op('-', $2); }
    | '(' expression ')'
    { $$ = $2; /* Return the inner expression's node */ }
    ;

func_call: ID '(' arg_list ')'
    { $$ = ast_new_func_call($1, $3); /* $1=Symbol*, $3=NodeList */ }
    ;

vector: '[' element_list ']'
      { $$ = $2; /* Return the NodeList node created by element_list */ }
      | '[' ']'
      { $$ = ast_new_vector(); /* Create an empty vector node */ }
      ;

element_list: expression
    { $$ = ast_new_vector(); ast_add_vector_element($$, $1); /* Create list, add first element */ }
    | element_list ',' expression
    { ast_add_vector_element($1, $3); $$ = $1; /* Add next element to existing list */ }
    ;

// Rules to build the argument list (NodeList struct)
arg_list: /* empty */
    { $$.items = NULL; $$.count = 0; $$.capacity = 0; /* Initialize empty NodeList */ }
    | arg_list_non_empty
    { $$ = $1; /* Pass through the constructed list */ }
    ;

arg_list_non_empty: expression
    { $$.items = NULL; $$.count = 0; $$.capacity = 0; /* Initialize new list */
      ast_add_argument(&$$, $1); /* Add first argument */ }
    | arg_list_non_empty ',' expression
    { $$ = $1; /* Use existing list */ 
      ast_add_argument(&$$, $3); /* Add next argument */ }
    ;

```

## 4. The Semantics

*   **Data Types:** The language supports two primary data types:
    *   `Scalar`: Represented internally and in generated C code as `double`.
    *   `Vector`: Represented as a dynamic array of doubles (`double*`) along with its size (`size_t`). In generated C code, this is managed via a `Vector` struct containing `data` and `size` fields.
*   **Scope:** There is a single, global lexical scope implemented using a simple linked-list symbol table (`symtab.c`).
*   **Variables:** Identifiers are looked up or inserted into the symbol table by the lexer. If an identifier is used in an expression before being assigned, it defaults to a scalar value of `0.0` (as per `symbol_insert` initialization).
*   **Assignment (`=`):** Assigns the value of the right-hand expression to the identifier on the left. Code generation performs a basic type check: scalar=scalar uses C assignment, vector=vector uses the `vector_assign` runtime helper (deep copy). Type mismatches during code generation produce warnings.
*   **Arithmetic Operators (`+`, `-`, `*`, `/`):**
    *   Defined for scalar-scalar operands, generating standard C arithmetic.
    *   Defined for vector-vector operands (element-wise), generating calls to runtime helper functions (`vector_add`, `vector_sub`, etc.). These helpers perform runtime checks for equal vector sizes. Division by zero is also checked at runtime.
    *   Defined for scalar-vector `+` (broadcast), generating calls to `vector_add_scalar`. Other scalar-vector ops are currently reported as errors during code generation.
    *   Unary `-` is defined for scalars.
*   **Control Flow:**
    *   `if (condition) statement1 [ else statement2 ]`: The `condition` expression must evaluate to a scalar. Non-zero values are considered true. Code generation produces standard C `if`/`else` blocks. Non-scalar conditions generate warnings and default to false.
    *   `while (condition) statement`: The `condition` expression must evaluate to a scalar. Non-zero values are true. Code generation produces a standard C `while` loop. Non-scalar conditions generate warnings and result in a non-executing loop (`while(0)`).
*   **Vector Literals (`[e1, e2, ...]`)**: Create a new vector value. Code generation creates a temporary C array and assigns it to a temporary `Vector` struct variable.
*   **Function Calls (`id(arg1, ...)`):** Used for external functions or built-ins.
    *   `read_vector()`: A built-in function that takes no arguments. Generates a call to `runtime_read_vector`, which reads space-separated doubles from `stdin` until newline and returns a `Vector`.
    *   `scatter_plot(vecX, vecY)`: A built-in visualization function. Expects two vector arguments. Generates a call to `c_scatter_plot`, which writes the data to `plot_data.txt` and executes `gnuplot plot.gp`. Runtime errors occur if arguments are not vectors or sizes mismatch.
    *   Other function calls `id(...)` generate generic C calls `id(...)`, assuming the function `id` is available at link time (e.g., from a C library) and returns a scalar. Vector arguments are passed as `vec.data, vec.size`.

## 5. Implementation Plan (Actual Steps Taken)

1.  **Initial Setup:** A `Makefile` was created to manage the build process using `flex`, `bison`, and `gcc`. Variables for tools and flags were defined. Build and clean targets were established.
2.  **Lexer/Parser Basics:** Initial versions of `scanner.l` (Flex) and `parser.y` (Bison) were created to recognize basic tokens (numbers, identifiers, operators) and parse simple expressions and assignments. Debug `printf` statements were used initially.
3.  **Abstract Syntax Tree (AST):** Data structures (`ast.h`, `ast.c`) were defined to represent the program structure (numbers, identifiers, vectors, binary/unary ops, assignments, statement lists). Functions to create and free AST nodes were implemented.
4.  **AST Construction:** Parser actions in `parser.y` were modified to build the AST using the defined constructor functions during parsing. The `%union` directive was used to pass AST node pointers. `yylval` handling was updated in `scanner.l`. An AST printing function was added for verification.
5.  **Symbol Table:** A simple linked-list symbol table (`symtab.h`, `symtab.c`) was implemented for the global scope to store variable names and their types/values (scalar or vector). Default initialization rules were added. AST nodes were updated to store `Symbol*` pointers instead of names. The lexer was updated to perform symbol lookup/insertion.
6.  **Code Generation Framework:** Basic code generation infrastructure (`codegen.h`, `codegen.c`) was created. This included opening an output C file, emitting C boilerplate (`main` function, includes), and establishing a recursive AST traversal function (`generate_statement`, `generate_expression`).
7.  **Runtime Helpers:** C helper functions for vector operations (create, free, assign, add, sub, mul, div) were designed and generated as part of `output.c`.
8.  **Code Generation Implementation:** Logic was added to `codegen.c` to translate specific AST nodes (assignments, expressions, literals) into corresponding C code, utilizing the runtime helpers and temporary variables.
9.  **Control Flow:** Grammar, AST, and code generation were extended to support `if`/`else` and `while` statements.
10. **Function Calls:** Grammar, AST, and code generation were extended for generic external function calls.
11. **Data Input:** A `read_vector()` primitive was added, involving a runtime helper function (`runtime_read_vector`) generated in `output.c` to read data from `stdin`.
12. **Visualization:** A `scatter_plot(vx, vy)` primitive was implemented. This involved a C runtime function (`src/runtime_viz.c`) linked with the generated code, which writes data to a file and calls `gnuplot`.
13. **Preprocessing:** A standalone Python script (`preprocess.py`) was created as an optional tool to extract numeric data suitable for piping to the generated executable.
14. **Error Handling:** Error reporting was improved in the parser (`yyerror`), semantic checks (type mismatches, wrong arguments) were added to the code generation phase, and runtime checks (vector size mismatch, division by zero) were added to the generated C helper functions.
15. **Build System Refinement:** The `Makefile` was updated iteratively to handle Windows command differences (`rm`, `mkdir`), add new source files (`ast.c`, `symtab.c`, `codegen.c`, `runtime_viz.c`), and add a target to compile the generated `output.c`, linking the runtime code. 