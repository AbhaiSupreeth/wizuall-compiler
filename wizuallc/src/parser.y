%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h> // Needed for strdup if used here, but prefer in lexer
#include "ast.h"    // Include AST definitions
#include "symtab.h" // Symbol table definitions

// Forward declaration for the lexer function generated by Flex
extern int yylex();
extern char *yytext; // Text of the matched token
extern int yylineno; // Line number tracking

// Error reporting function required by Bison
void yyerror(const char *s);

// Global variable to store the root of the AST
ASTNode *ast_root = NULL;
%}

/* Define the union of possible semantic values */
%union {
    double number_val;     // For NUMBER tokens
    struct Symbol* symbol_ptr; // For ID tokens and symbols
    struct ASTNode* node_ptr; // For non-terminals returning AST nodes
    NodeList node_list; // Add type for argument list construction
}

/* Declare tokens with their types from the union */
%token <number_val> NUMBER
%token <symbol_ptr> ID // ID token now carries a Symbol*
%token IF ELSE WHILE // New keywords

/* Declare non-terminals with their types from the union */
%type <node_ptr> program statement_list statement assignment expression vector element_list block func_call
%type <node_list> arg_list arg_list_non_empty // For building the list

/* Define operator precedence and associativity */
%left '+' '-'
%left '*' '/'
%precedence UMINUS /* Give unary minus higher precedence */
%nonassoc IFX     /* Precedence for IF without ELSE */
%nonassoc ELSE    /* Lowest precedence for ELSE */
%right '(' ')' // Give function call precedence (often high)

/* Define the start symbol (top-level rule) */
%start program

%%

/* Grammar Rules */

program: statement_list
    { ast_root = $1; /* Assign the final list to the global root */ }
    ;

statement_list: /* empty */
    { $$ = ast_new_statement_list(); }
    | statement_list statement
    { if ($2) ast_add_statement($1, $2); $$ = $1; /* Add non-null statement */ }
    ;

statement: assignment ';'
    { $$ = $1; }
    | expression ';'
    { $$ = $1; }
    | vector ';'
    { $$ = $1; }
    | block
    { $$ = $1; /* Block itself is a statement list node */ }
    | IF '(' expression ')' statement %prec IFX /* Dangling else resolution */
    { $$ = ast_new_if($3, $5, NULL); }
    | IF '(' expression ')' statement ELSE statement
    { $$ = ast_new_if($3, $5, $7); }
    | WHILE '(' expression ')' statement
    { $$ = ast_new_while($3, $5); }
    | ';'
    { $$ = NULL; /* Represent empty statement as NULL? Or create a specific node? NULL for now */ }
    ;

block: '{' statement_list '}'
    { $$ = $2; /* Return the statement list node */ }
    ;

assignment: ID '=' expression
    { $$ = ast_new_assignment($1, $3); /* $1 is Symbol* from lexer */ }
    ;

expression: NUMBER
    { $$ = ast_new_number($1); /* $1 is double from lexer */ }
    | ID
    { $$ = ast_new_identifier($1); /* $1 is Symbol* from lexer */ }
    | vector
    { $$ = $1; }
    | func_call
    { $$ = $1; }
    | expression '+' expression
    { $$ = ast_new_binary_op('+', $1, $3); }
    | expression '-' expression
    { $$ = ast_new_binary_op('-', $1, $3); }
    | expression '*' expression
    { $$ = ast_new_binary_op('*', $1, $3); }
    | expression '/' expression
    { $$ = ast_new_binary_op('/', $1, $3); }
    | '-' expression %prec UMINUS /* Unary minus */
    { $$ = ast_new_unary_op('-', $2); }
    | '(' expression ')'
    { $$ = $2; /* Return the inner expression's node */ }
    /* Add vector access later: ID '[' expression ']' */
    ;

func_call: ID '(' arg_list ')'
    { $$ = ast_new_func_call($1, $3); /* $1=Symbol*, $3=NodeList */ }
    ;

vector: '[' element_list ']'
      { $$ = $2; /* Return the NodeList node created by element_list */ }
      | '[' ']'
      { $$ = ast_new_vector(); /* Create an empty vector node */ }
      ;

element_list: expression
    { $$ = ast_new_vector(); ast_add_vector_element($$, $1); /* Create list, add first element */ }
    | element_list ',' expression
    { ast_add_vector_element($1, $3); $$ = $1; /* Add next element to existing list */ }
    ;

// Rules to build the argument list (NodeList struct)
arg_list: /* empty */
    { $$.items = NULL; $$.count = 0; $$.capacity = 0; /* Initialize empty NodeList */ }
    | arg_list_non_empty
    { $$ = $1; /* Pass through the constructed list */ }
    ;

arg_list_non_empty: expression
    { $$.items = NULL; $$.count = 0; $$.capacity = 0; /* Initialize new list */
      ast_add_argument(&$$, $1); /* Add first argument */ }
    | arg_list_non_empty ',' expression
    { $$ = $1; /* Use existing list */ 
      ast_add_argument(&$$, $3); /* Add next argument */ }
    ;

%%

/* C code section */

// Error reporting function
void yyerror(const char *s) {
    // Use yylineno if the lexer provides it
    fprintf(stderr, "Syntax error at line %d: %s near '%s'\n", yylineno, s, yytext);
    exit(1); // Exit on first error for simplicity now
}

// Remove the basic main function for testing standalone parser
// Use the main function in main.c instead. 